Slasti version 1.92.dev
Unfortunately, Oishii was taken, so Slasti it is. It's good to be trilingual.

TODO:
 - invoke del2sla from an upload form
 - dedup URLs (show found ones at the time of entry)
 - search, aggregate in tags page - for tablets with poor ^F
 - localizations
 - tests (Christan's main() in template.py lacked verification)
 - template docs for 2.0
   - macro variables list - document starting with underscore
   - parse and beautify devel notes (again)
 - make .substitute to return a list-of-strings; million useless .join now
 - replace sgmllib.SGMLParser with something better. Fails at HTML:
http://www.reallifecomics.com/
<title>Real Life Comics - The Online Comic &copy;1999-2010 Greg Dean</title>

fixup TODO for templates:
 - rename "jsondict" into something sensible

zaitcev@kotori.zaitcev.us

----- bookmarklet - XXX not parameterized; XXX login needs fixing
  <a href="javascript:location.href=
           'https://slasti.zaitcev.us/zaitcev/new' +
           '?title=' + encodeURIComponent(document.title) +
           '&href=' + encodeURIComponent(location.href)
          ">Post to Slasti</a>


================================================================
Slasti development notes

Internally, all data strings are unicode (there may be some byte strings
for things like HTTP's "200 OK" and header names, but never for data).
Decoding/encoding should be done "on the border" or very closeby.

Decoding raw bytes on input:

 * ctx.path is already unicode, this is handled by slasti.wsgi.
 * pinput and query strings should be obtained via ctx.get_pinput_arg() and
   ctx.get_query_arg() respectively. They handle encoding issues.

The storage backend (i.e. tagbase.py) operates on unicode strings. Internally it
stores tags base64 encoded as filenames, while content of bookmarks is saved in
files encoded as utf-8.

Encoding unicode strings on output:

Can either be done in Template.substitute() (as currently) or in slasti.wsgi.
Neither is particularly tricky. What's difficult, however, is proper escaping.

The problem is that we actually want to escape strings in two different ways
for output:
 * URL encoding like urllib.quote() / urllib.quote_plus
   Noteworthy: quote() output is bytes, but contains only [A-Za-z0-9_.%/+-]
   Thus it can be turned into unicode with a unicode(quote(...)) conversion.
   Also, calling cgi.escape() on the resulting string doesn't alter it.
 * Generic HTML encoding like cgi.escape()
   _Everything_ that ends up in the HTML file has to be escaped like this,
   otherwise we're vulnerable to XSS attacks.

Solution for the output encoding problem:
 * Encode all user-generated content that ends up in URLs with
   slasti.escapeURLComponent(). This does urllib.quote_plus() and returns
   unicode.
 * The bookmark URL can't be handled like that (because quote_plus clobbers the
   :// portion of the URL). Use slasti.escapeURL(). The resulting string is
   unicode and is safe to use within attributes.
 * Everything else should end up in jsondict as unescaped unicode, escaping and
   encoding is handled in the templating engine.
   -- this breaks for variables that contain HTML, they start with '_'.
 * Template().substitute() returns bytes. Attempt to process it causes
   UnicodeDecodeError, but we just return it to the wsgi server.
   In order to make a substitute to call substitute, we created substitute_2.
